package vybiumstarksvm

import (
	"math/big"

	"github.com/vybium/vybium-crypto/pkg/vybium-crypto/field"
	"github.com/vybium/vybium-starks-vm/internal/vybium-starks-vm/core"
	"github.com/vybium/vybium-starks-vm/internal/vybium-starks-vm/protocols"
	"github.com/vybium/vybium-starks-vm/internal/vybium-starks-vm/vm"
)

// Prover is the public interface for generating zkSTARK proofs
type Prover interface {
	// GenerateProof generates a zkSTARK proof for the given execution trace
	GenerateProof(trace *ExecutionTrace) (*Proof, error)
}

// Verifier is the public interface for verifying zkSTARK proofs
type Verifier interface {
	// VerifyProof verifies a zkSTARK proof
	VerifyProof(proof *Proof, claim *Claim) (*ProofVerificationResult, error)
}

// proverImpl is the internal implementation of Prover
type proverImpl struct {
	field  *core.Field
	config *Config
	prover *protocols.Prover
}

// verifierImpl is the internal implementation of Verifier
type verifierImpl struct {
	field    *core.Field
	config   *Config
	verifier *protocols.Verifier
}

// NewProver creates a new STARK prover with the given configuration
func NewProver(config *Config) (Prover, error) {
	// Parse field modulus
	modulus := new(big.Int)
	if _, ok := modulus.SetString(config.FieldModulus, 10); !ok {
		return nil, &VMError{
			Code:    ErrInvalidConfig,
			Message: "invalid field modulus",
		}
	}

	// Create field for compatibility (some internal components still use it)
	field, err := core.NewField(modulus)
	if err != nil {
		return nil, &VMError{
			Code:    ErrFieldCreation,
			Message: "failed to create field: " + err.Error(),
		}
	}

	// Create STARK parameters from config
	params := protocols.STARKParameters{
		SecurityLevel:         config.SecurityLevel,
		FRIExpansionFactor:    config.BlowupFactor,
		NumTraceRandomizers:   20,                // Standard STARK parameter
		NumCollinearityChecks: config.FRIQueries, // Use FRIQueries from config
	}

	// Create internal prover (no longer requires field parameter)
	prover, err := protocols.NewProver(params)
	if err != nil {
		return nil, &VMError{
			Code:    ErrProofGeneration,
			Message: "failed to create prover: " + err.Error(),
			Cause:   err,
		}
	}

	return &proverImpl{
		field:  field,
		config: config,
		prover: prover,
	}, nil
}

// NewVerifier creates a new STARK verifier with the given configuration
func NewVerifier(config *Config) (Verifier, error) {
	// Parse field modulus
	modulus := new(big.Int)
	if _, ok := modulus.SetString(config.FieldModulus, 10); !ok {
		return nil, &VMError{
			Code:    ErrInvalidConfig,
			Message: "invalid field modulus",
		}
	}

	// Create field (still needed for verifier)
	field, err := core.NewField(modulus)
	if err != nil {
		return nil, &VMError{
			Code:    ErrFieldCreation,
			Message: "failed to create field: " + err.Error(),
		}
	}

	// Create STARK parameters from config
	params := protocols.STARKParameters{
		SecurityLevel:         config.SecurityLevel,
		FRIExpansionFactor:    config.BlowupFactor,
		NumTraceRandomizers:   20,                // Standard STARK parameter
		NumCollinearityChecks: config.FRIQueries, // Use FRIQueries from config
	}

	// Create internal verifier (still requires field parameter)
	verifier, err := protocols.NewVerifier(field, params)
	if err != nil {
		return nil, &VMError{
			Code:    ErrProofVerification,
			Message: "failed to create verifier: " + err.Error(),
			Cause:   err,
		}
	}

	return &verifierImpl{
		field:    field,
		config:   config,
		verifier: verifier,
	}, nil
}

// GenerateProof generates a zkSTARK proof for the given execution trace
func (p *proverImpl) GenerateProof(trace *ExecutionTrace) (*Proof, error) {
	// Check if trace has the internal AET
	if trace == nil {
		return nil, &VMError{
			Code:    ErrInvalidInput,
			Message: "execution trace is nil",
		}
	}

	// Get the internal AET from the trace
	if trace.internalAET == nil {
		return nil, &VMError{
			Code:    ErrInvalidInput,
			Message: "execution trace does not contain internal AET - was it generated by VM execution?",
		}
	}

	// Type assert to the actual AET type
	aet, ok := trace.internalAET.(protocols.ExecutionTrace)
	if !ok {
		return nil, &VMError{
			Code:    ErrInvalidInput,
			Message: "internal AET has wrong type",
		}
	}

	// Extract program digest from AET
	// The AET contains the TIP-0006 compliant program attestation digest
	var programDigest []field.Element
	if aetData, ok := aet.GetTableData().(*vm.AET); ok {
		programDigest = aetData.GetProgramDigest()
	} else {
		// Fallback: use zero digest if cast fails
		programDigest = make([]field.Element, 5)
		for i := range programDigest {
			programDigest[i] = field.Zero
		}
	}

	// Create a claim for the proof
	claim := &protocols.Claim{
		ProgramDigest: programDigest,
		Version:       0,
		PublicInput:   convertToInternalFieldElements(trace.PublicInput),
		PublicOutput:  convertToInternalFieldElements(trace.PublicOutput),
	}

	// Generate the proof using the internal prover
	proof, err := p.prover.Prove(claim, aet)
	if err != nil {
		return nil, &VMError{
			Code:    ErrProofGeneration,
			Message: "proof generation failed: " + err.Error(),
			Cause:   err,
		}
	}

	return proof, nil
}

// Helper function to convert public field elements to internal format
func convertToInternalFieldElements(elems []*FieldElement) []field.Element {
	result := make([]field.Element, len(elems))
	for i, elem := range elems {
		if elem != nil {
			result[i] = field.New(elem.Big().Uint64())
		}
	}
	return result
}

// VerifyProof verifies a zkSTARK proof
func (v *verifierImpl) VerifyProof(proof *Proof, claim *Claim) (*ProofVerificationResult, error) {
	// Validate inputs
	if proof == nil {
		return nil, &VMError{
			Code:    ErrInvalidInput,
			Message: "proof is nil",
		}
	}

	if claim == nil {
		return nil, &VMError{
			Code:    ErrInvalidInput,
			Message: "claim is nil",
		}
	}

	// Verify the proof using internal verifier
	err := v.verifier.Verify(claim, proof)
	if err != nil {
		return &ProofVerificationResult{
			Valid: false,
			Error: "verification failed: " + err.Error(),
		}, nil
	}

	return &ProofVerificationResult{
		Valid: true,
		Error: "",
	}, nil
}

// DefaultConfig returns a default configuration for 160-bit security
// Uses Goldilocks field for efficient arithmetic operations
func DefaultConfig() *Config {
	return &Config{
		FieldModulus:     "18446744069414584321", // Goldilocks: 2^64 - 2^32 + 1
		SecurityLevel:    160,
		TraceLength:      1024,
		EvaluationDomain: 8192,
		FRIQueries:       2,
		BlowupFactor:     4, // FRI expansion factor
	}
}
